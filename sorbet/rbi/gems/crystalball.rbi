# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/crystalball/all/crystalball.rbi
#
# crystalball-0.7.0

module Crystalball
  def self.config; end
  def self.configured_level; end
  def self.foresee(workdir: nil, map_path: nil, &block); end
  def self.log_file_output_stream; end
  def self.output_stream; end
  def self.severity(severity_sym); end
  extend Crystalball::Logging
end
module Crystalball::Logging
  def config; end
  def configured_level; end
  def log(severity_sym, *args, &block); end
  def log_file_output_stream; end
  def output_stream; end
  def reset_logger; end
  def self.extended(base); end
  def severity(severity_sym); end
end
class Crystalball::SourceDiff
  def changeset; end
  def each; end
  def empty?; end
  def from(*args, &block); end
  def git_diff; end
  def initialize(git_diff); end
  def lines(*args, &block); end
  def repository; end
  def size(*arg0); end
  def stats(*args, &block); end
  def to(*args, &block); end
  extend Forwardable
  include Enumerable
end
class Crystalball::SourceDiff::FileDiff
  def deleted?; end
  def git_diff; end
  def initialize(git_diff); end
  def method_missing(method, *args, &block); end
  def modified?; end
  def moved?; end
  def new?; end
  def new_relative_path; end
  def relative_path; end
  def respond_to_missing?(method, *arg1); end
end
module Crystalball::SourceDiff::FormattingChecker
  def self.collect_patch(patch, sign); end
  def self.pure_formatting?(file_diff); end
  def self.stripable_file?(file_name); end
  def self.trim_patch(patch); end
end
class Crystalball::GitRepo
  def diff(from = nil, to = nil); end
  def initialize(repo_path); end
  def method_missing(method, *args, &block); end
  def repo; end
  def repo_path; end
  def respond_to_missing?(method, *arg1); end
  def self.exists?(path); end
  def self.open(repo_path); end
end
module Git
end
class Git::Base
  def merge_base(*args); end
end
class Git::Lib
end
module Crystalball::RSpec
end
class Crystalball::RSpec::PredictionBuilder
  def config; end
  def execution_map; end
  def expired_map?; end
  def initialize(config = nil); end
  def prediction; end
  def predictor(&block); end
  def repo; end
end
class Crystalball::RSpec::Filtering
  def configuration; end
  def initialize(configuration); end
  def remove_unecessary_filters_from_directories(directories); end
  def remove_unecessary_filters_from_files(files); end
  def remove_unnecessary_filters(files_or_directories); end
  def self.remove_unnecessary_filters(config, paths); end
end
module Crystalball::RSpec::PredictionPruning
  def examples_limit; end
  def reconfiguration_needed?; end
  def reconfigure_to_limit; end
  def self.included(base); end
end
class Crystalball::RSpec::PredictionPruning::ExamplesPruner
  def add_examples(group, resulting_set); end
  def initialize(rspec_world, to:); end
  def limit; end
  def prune_to_limit(group, resulting_set); end
  def pruned_set; end
  def world; end
end
class Crystalball::RSpec::PredictionPruning::ExamplesPruner::ContextIdsSet
  def add(id, size = nil); end
  def ids; end
  def initialize; end
  def size; end
  def to_a; end
end
module Crystalball::RSpec::PredictionPruning::ClassMethods
  def examples_limit; end
  def prune_prediction_to_limit(prediction); end
end
class Crystalball::RSpec::StandardPredictionBuilder < Crystalball::RSpec::PredictionBuilder
  def predictor; end
end
class Crystalball::RSpec::Runner < RSpec::Core::Runner
  def configure(err, out); end
  def self.build_prediction; end
  def self.check_map; end
  def self.config; end
  def self.config=(arg0); end
  def self.config_file; end
  def self.load_execution_map; end
  def self.prediction_builder; end
  def self.prediction_builder=(arg0); end
  def self.prepare; end
  def self.reset!; end
  def self.run(args, err = nil, out = nil); end
  def setup(err, out); end
  extend Crystalball::RSpec::PredictionPruning::ClassMethods
  include Crystalball::RSpec::PredictionPruning
end
class Crystalball::RSpec::Runner::Configuration
  def [](key); end
  def execution_map_path; end
  def initialize(config = nil); end
  def log_file; end
  def prediction_builder_class; end
  def raw_value(key); end
  def repo_path; end
  def run_requires; end
  def runner_class; end
  def to_h; end
  def values; end
end
class Crystalball::Prediction
  def compact; end
  def initialize(records); end
  def method_missing(*args, &block); end
  def records; end
  def respond_to_missing?(*args); end
  def to_a; end
end
class Crystalball::Predictor
  def diff; end
  def extract_file_path(example); end
  def filter(example_groups); end
  def from; end
  def initialize(map, repo, from: nil, to: nil); end
  def map; end
  def predict!(current_diff); end
  def prediction; end
  def prediction_strategies; end
  def raw_prediction(current_diff); end
  def repo; end
  def to; end
  def use(strategy); end
end
module Crystalball::Predictor::Helpers
end
module Crystalball::Predictor::Helpers::PathFormatter
  def format_path(path); end
  def format_paths(paths); end
end
module Crystalball::Predictor::Strategy
  def call(*arg0); end
  include Crystalball::Predictor::Helpers::PathFormatter
end
module Crystalball::Predictor::Helpers::AffectedExampleGroupsDetector
  def detect_examples(files, map); end
end
class Crystalball::Predictor::ModifiedExecutionPaths
  def call(diff, map); end
  include Crystalball::Predictor::Helpers::AffectedExampleGroupsDetector
  include Crystalball::Predictor::Strategy
end
class Crystalball::Predictor::ModifiedSpecs
  def call(diff, _); end
  def initialize(spec_pattern = nil); end
  def spec_pattern; end
  include Crystalball::Predictor::Strategy
end
class Crystalball::Predictor::ModifiedSupportSpecs
  def call(diff, map); end
  def initialize(support_spec_pattern = nil); end
  def support_spec_pattern; end
  include Crystalball::Predictor::Helpers::AffectedExampleGroupsDetector
  include Crystalball::Predictor::Strategy
end
class Crystalball::Predictor::AssociatedSpecs
  def call(diff, _map); end
  def captures(file_path); end
  def from; end
  def initialize(from:, to:); end
  def to; end
  include Crystalball::Predictor::Strategy
end
class Crystalball::ExampleGroupMap
  def each(*args, &block); end
  def file_path; end
  def initialize(example, used_files = nil); end
  def push(*args, &block); end
  def uid; end
  def used_files; end
  extend Forwardable
end
class Crystalball::ExecutionMap
  def <<(example_group_map); end
  def clear!; end
  def commit(*args, &block); end
  def example_groups; end
  def example_groups=(arg0); end
  def initialize(metadata: nil, example_groups: nil); end
  def metadata; end
  def metadata=(arg0); end
  def size(*args, &block); end
  def timestamp(*args, &block); end
  def version(*args, &block); end
  extend Forwardable
end
class Crystalball::ExecutionMap::Metadata
  def commit; end
  def initialize(commit: nil, type: nil, version: nil, timestamp: nil); end
  def timestamp; end
  def to_h; end
  def type; end
  def version; end
end
class Crystalball::MapGenerator
  def check_dump_threshold; end
  def configuration; end
  def dump_threshold(*args, &block); end
  def finalize!; end
  def initialize; end
  def map; end
  def map=(arg0); end
  def map_class(*args, &block); end
  def map_storage(*args, &block); end
  def refresh_for_case(example); end
  def repo; end
  def self.start!(&block); end
  def start!; end
  def started; end
  def started=(arg0); end
  def strategies(*args, &block); end
  extend Forwardable
end
class Crystalball::MapGenerator::StrategiesCollection
  def _strategies; end
  def initialize(strategies = nil); end
  def method_missing(method_name, *args, &block); end
  def respond_to_missing?(method_name, *_args); end
  def run(example_group_map, example, &block); end
  def run_for_strategies(example_group_map, example, *strats, &block); end
  include Enumerable
end
class Crystalball::MapGenerator::Configuration
  def commit; end
  def commit=(arg0); end
  def compact_map; end
  def compact_map=(arg0); end
  def compact_map?; end
  def dump_threshold; end
  def dump_threshold=(value); end
  def initialize; end
  def map_class; end
  def map_class=(arg0); end
  def map_storage; end
  def map_storage=(arg0); end
  def map_storage_path; end
  def map_storage_path=(value); end
  def register(strategy); end
  def strategies; end
  def version; end
  def version=(arg0); end
end
module Crystalball::MapGenerator::BaseStrategy
  def after_register; end
  def after_start; end
  def before_finalize; end
  def call(_example_map, _example); end
end
module Crystalball::MapGenerator::Helpers
end
module Crystalball::MapGenerator::Helpers::PathFilter
  def filter(paths); end
  def initialize(root_path = nil); end
  def root_path; end
end
class Crystalball::MapGenerator::CoverageStrategy
  def after_register; end
  def call(example_map, example); end
  def execution_detector; end
  def initialize(execution_detector = nil); end
  include Crystalball::MapGenerator::BaseStrategy
end
class Crystalball::MapGenerator::CoverageStrategy::ExecutionDetector
  def detect(before, after); end
  include Crystalball::MapGenerator::Helpers::PathFilter
end
class Crystalball::MapGenerator::ObjectSourcesDetector
  def after_register; end
  def before_finalize; end
  def definition_tracer; end
  def detect(objects); end
  def hierarchy_fetcher; end
  def initialize(root_path:, definition_tracer: nil, hierarchy_fetcher: nil); end
  include Crystalball::MapGenerator::Helpers::PathFilter
end
class Crystalball::MapGenerator::ObjectSourcesDetector::HierarchyFetcher
  def ancestors_for(mod); end
  def initialize(stop_modules = nil); end
  def pick_ancestors(mod); end
  def stop_consts; end
  def stop_modules; end
end
class Crystalball::MapGenerator::ObjectSourcesDetector::DefinitionTracer
  def constants_definition_paths; end
  def constants_definition_paths=(arg0); end
  def initialize(root_path); end
  def root_path; end
  def start; end
  def stop; end
  def trace_point; end
  def trace_point=(arg0); end
end
class Crystalball::MapGenerator::AllocatedObjectsStrategy
  def after_register(*args, &block); end
  def before_finalize(*args, &block); end
  def call(example_map, example); end
  def execution_detector; end
  def initialize(execution_detector:, object_tracker:); end
  def object_tracker; end
  def self.build(only: nil, root: nil); end
  extend Forwardable
  include Crystalball::MapGenerator::BaseStrategy
end
class Crystalball::MapGenerator::AllocatedObjectsStrategy::ObjectTracker
  def created_object_classes; end
  def created_object_classes=(arg0); end
  def initialize(only_of: nil); end
  def only_of; end
  def trace_point; end
  def used_classes_during(&block); end
  def whitelisted_constants; end
end
class Crystalball::MapGenerator::DescribedClassStrategy
  def after_register(*args, &block); end
  def before_finalize(*args, &block); end
  def call(example_map, example); end
  def execution_detector; end
  def initialize(execution_detector: nil); end
  extend Forwardable
  include Crystalball::MapGenerator::BaseStrategy
end
class Crystalball::MapStorage
end
class Crystalball::MapStorage::NoFilesFoundError < StandardError
end
class Crystalball::MapStorage::YAMLStorage
  def clear!; end
  def dump(data); end
  def initialize(path); end
  def path; end
  def self.guard_metadata_consistency(metadata); end
  def self.load(path); end
  def self.read_files(path); end
end
module Crystalball::MapCompactor
  def self.compact_examples!(example_groups); end
  def self.compact_map!(map); end
  def self.example_filename(example_id); end
end
class Crystalball::MapCompactor::ExampleContext
  def address; end
  def depth; end
  def include?(example_id); end
  def initialize(address); end
  def parent; end
end
class Crystalball::MapCompactor::ExampleGroupsDataCompactor
  def compact!; end
  def compact_context!(context); end
  def compact_data; end
  def deep_used_files(context); end
  def extract_contexts(example_uids); end
  def initialize(plain_data); end
  def plain_data; end
  def self.compact!(plain_data); end
end
